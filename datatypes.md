# Core-JS study

## 데이터 타입

</br>

- 목차

1. [데이터 타입의 종류](https://github.com/sugyinbrs/Core-JS/edit/main/datatypes.md#1-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85%EC%9D%98-%EC%A2%85%EB%A5%98)
2. [데이터 타입을 구분하는 이유와 차이](https://github.com/sugyinbrs/Core-JS/edit/main/datatypes.md#2-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85%EC%9D%84-%EA%B5%AC%EB%B6%84%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0%EC%99%80-%EC%B0%A8%EC%9D%B4)  
   2-1. [기본형 데이터 변경](https://github.com/sugyinbrs/Core-JS/edit/main/datatypes.md#2-1-%EA%B8%B0%EB%B3%B8%ED%98%95-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B3%80%EA%B2%BD)  
   2-2. [참조형 데이터 변경](https://github.com/sugyinbrs/Core-JS/edit/main/datatypes.md#2-2-%EC%B0%B8%EC%A1%B0%ED%98%95-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B3%80%EA%B2%BD)

</br>
</br>
</br>

> ## 1. 데이터 타입의 종류

</br>
</br>
</br>

#### 1) Primitive Type (기본형)

- Number
- String
- Boolean
- null
- undefined
- (Symbol (ES6))

</br>

#### 2) Reference Type (참조형)

- Object
  - Array
  - Function
  - RegExp
  - (Set / WeakSet (ES6))
  - (Map / WeakMap (ES6))

</br>
</br>
</br>

> ## 2. 데이터 타입을 구분하는 이유와 차이

</br>
</br>
</br>

각 데이터가 메모리상에서 저장되는 형태를 통해서 살펴볼 것이다.  
</br>

실제 자바스크립트 메모리 구조는 <strong>스택 메모리, 힙 메모리</strong> 영역으로 나뉘어 있다.

</br>
</br>

#### a) stack memory

- 변수
- 기본형 데이터
- 정적 할당

</br>

#### b) heap memory

- 참조형 데이터
- 동적 할당

</br>
</br>

메모리는 이정도로만 구분하며 앞으로 메모리 라는 한 단어로 추상화 시켜 설명한다.

</br>

데이터 변경 시에는 기본형과 참조형 데이터가 어떻게 변경이 되는지 알아본다.

</br>
</br>
</br>

### 2-1. 기본형 데이터 변경

</br>
</br>
</br>

```js
var a; // a 선언 시 메모리 안에서 데이터가 담길 공간을 미리 확보 (1003)

a = "abc"; // abc 할당 시 비어있는 다른 메모리 공간에 저장 (5004)
```

</br>

|  주소  | ... | 1002 |       1003        | 1004 | 1005 | ... |
| :----: | --- | ---- | :---------------: | ---- | ---- | --- |
| 데이터 |     |      | 이름: a </br> 값: |      |      |     |

</br>

|  주소  | ... | 5002 | 5003 | 5004  | 5005 | ... |
| :----: | --- | ---- | ---- | :---: | ---- | --- |
| 데이터 |     |      |      | 'abc' |      |     |

</br>
</br>
</br>

    5004라는 주소값을 가지고 변수 a가 가리키는 주소로 이동하고자 함
    > 메모리를 검색해보다가 1003번의 식별자가 a 인 것을 확인
    > 1003번의 값에 5004를 넣게 됨

</br>

|  주소  | ... | 1002 |          1003           | 1004 | 1005 | ... |
| :----: | --- | ---- | :---------------------: | ---- | ---- | --- |
| 데이터 |     |      | 이름: a </br> 값: @5004 |      |      |     |

</br>

|  주소  | ... | 5002 | 5003 | 5004  | 5005 | ... |
| :----: | --- | ---- | ---- | :---: | ---- | --- |
| 데이터 |     |      |      | 'abc' |      |     |

</br>
</br>
</br>

```js
var a; // a 선언 시 메모리 안에서 데이터가 담길 공간을 미리 확보 (1003)

a = "abc"; // abc 할당 시 비어있는 다른 메모리 공간에 저장 (5004)

a = "abcdef"; // a 에 abcdef 라는 새로운 값 할당 시 비어있는 다른 메모리 공간에 저장 (5005)
```

</br>

|  주소  | ... | 1002 |          1003           | 1004 | 1005 | ... |
| :----: | --- | ---- | :---------------------: | ---- | ---- | --- |
| 데이터 |     |      | 이름: a </br> 값: @5005 |      |      |     |

</br>

|  주소  | ... | 5002 | 5003 | 5004  |   5005   | ... |
| :----: | --- | ---- | ---- | :---: | :------: | --- |
| 데이터 |     |      |      | 'abc' | 'abcdef' |     |

</br>
</br>
</br>

### 2-2. 참조형 데이터 변경

</br>
</br>
</br>

### 2-2-1. 객체 데이터 변경

</br>
</br>
</br>

아래와 같이 선언된 obj 라는 객체가 있다.

```js
var obj = {
  a: 1,
  b: "bbb",
};
```

</br>

그런데 컴퓨터는 위의 식을 아래와 같이 <strong>선언 후 할당</strong> 하는 과정으로 인식한다.

```js
var obj;

obj = {
  a: 1,
  b: "bbb",
};
```

</br>
</br>
</br>

다시 돌아와서 참조형 데이터 변경 과정을 차근 차근 살펴본다.

</br>

```js
var obj = {
  a: 1,
  b: "bbb",
};
```

    obj를 선언
    > 데이터를 넣을 임의의 공간 선정 (5002)
    > 메모리 구조 상 값이 하나만 들어갈 수 있음
    > 5002에서는 7103번부터 프로퍼티를 저장할 특정 공간 확보, 객체 obj의 프로퍼티들이라 규정
    > 각 프로퍼티에 대한 선언과 할당은 기본형 데이터 변경 과정과 동일하게 진행, 7103 에 식별자 a를 넣고 해당 값인 1을 넣기 위한 5003번 확보, 7103 값에 5003 을 넣게 됨

</br>

|  주소  | ... |        1002         | 1003 | 1004 | ... |
| :----: | --- | :-----------------: | ---- | ---- | --- |
| 데이터 |     | 이름: obj </br> 값: |      |      |     |

</br>

|  주소  | ... |   5002    | 5003 | 5004 | 5005 | 5006 | ... |
| :----: | --- | :-------: | :--: | :--: | :--: | ---- | --- |
| 데이터 |     | @7103 ~ ? |  1   |      |      |      |     |

</br>

|  주소  | ... |          7103           | 7104 | 7105 | ... |
| :----: | --- | :---------------------: | ---- | ---- | --- |
| 데이터 |     | 이름: a </br> 값: @5003 |      |      |     |

</br>

|  주소  | ... | 8104 | 8105 | 8106 | 8107 | 8108 | ... |
| :----: | --- | ---- | ---- | :--: | :--: | ---- | --- |
| 데이터 |     |      |      |      |      |      |     |

</br>
</br>
</br>

    7104번의 식별자를 b로 지정
    > 5004에 문자열 'bbb' 저장
    > 객체 내부 프로퍼티 모두 할당 완료
    > 5002라는 주소값을 가지고 변수 obj를 가리키는 주소로 이동
    > 1002 값에 5002를 할당

</br>

|  주소  | ... |           1002            | 1003 | 1004 | ... |
| :----: | --- | :-----------------------: | ---- | ---- | --- |
| 데이터 |     | 이름: obj </br> 값: @5002 |      |      |     |

</br>

|  주소  | ... |   5002    | 5003 | 5004  | 5005 | 5006 | ... |
| :----: | --- | :-------: | :--: | :---: | :--: | ---- | --- |
| 데이터 |     | @7103 ~ ? |  1   | 'bbb' |      |      |     |

</br>

|  주소  | ... |          7103           |          7104           | 7105 | ... |
| :----: | --- | :---------------------: | :---------------------: | ---- | --- |
| 데이터 |     | 이름: a </br> 값: @5003 | 이름: b </br> 값: @5004 |      |     |

</br>

|  주소  | ... | 8104 | 8105 | 8106 | 8107 | 8108 | ... |
| :----: | --- | ---- | ---- | :--: | :--: | ---- | --- |
| 데이터 |     |      |      |      |      |      |     |

</br>
</br>
</br>

```js
var obj = {
  a: 1,
  b: "bbb",
};

obj.a = 2; // a 프로퍼티의 값을 2로 재할당
```

</br>

    2라는 값을 새로운 데이터에 저장 (5005)
    > 5005 주소 값을 가지고 obj.a 를 찾음
    > 1002
    > 5002
    > a 프로퍼티를 찾음
    > 7103 을 찾게 되고 7103 의 값을 5003 대신 5005로 재할당

</br>

|  주소  | ... |           1002            | 1003 | 1004 | ... |
| :----: | --- | :-----------------------: | ---- | ---- | --- |
| 데이터 |     | 이름: obj </br> 값: @5002 |      |      |     |

</br>

|  주소  | ... |   5002    | 5003 | 5004  | 5005 | 5006 | ... |
| :----: | --- | :-------: | :--: | :---: | :--: | :--: | --- |
| 데이터 |     | @7103 ~ ? |  1   | 'bbb' |  2   |      |     |

</br>

|  주소  | ... |          7103           |          7104           | 7105 | ... |
| :----: | --- | :---------------------: | :---------------------: | ---- | --- |
| 데이터 |     | 이름: a </br> 값: @5005 | 이름: b </br> 값: @5004 |      |     |

</br>

|  주소  | ... | 8104 | 8105 | 8106 | 8107 | 8108 | ... |
| :----: | --- | ---- | ---- | :--: | :--: | ---- | --- |
| 데이터 |     |      |      |      |      |      |     |

</br>
</br>
</br>

### 2-2-2. 객체 내부 프로퍼티에 배열이 있는 데이터 변경

</br>
</br>
</br>

```js
var obj = {
  a: 3,
  arr: [3, 4],
};
```

</br>

    x: 3 프로퍼티는 기존과 동일하게 진행
    > 객체 값이 있는 프로퍼티 arr 식별자를 7104에 저장
    > 배열 역시 참조형 데이터이므로 배열 인덱스를 저장할 공간을 5004에 저장
    > 0번 째 인덱스의 값 3은 5003에 있으니 그 주소 값을 재사용하여 8104에 저장
    > 1번 째 인덱스 값 4는 5005에 새로 저장 후 그 주소값을 8105에 저장
    > 배열 모두 할당 완료
    > 5004라는 주소값을 가지고 arr 식별자를 가리키는 주소로 이동 (7104) 후 주소값 저장
    > 객체 내부 프로퍼티 모두 할당 완료
    > 5002라는 주소값을 가지고 변수 obj를 가리키는 주소로 이동
    > 1002 값에 5002를 할당

</br>

|  주소  | ... |           1002            | 1003 | 1004 | ... |
| :----: | --- | :-----------------------: | ---- | ---- | --- |
| 데이터 |     | 이름: obj </br> 값: @5002 |      |      |     |

</br>

|  주소  | ... |   5002    | 5003 |   5004    | 5005 | 5006 | ... |
| :----: | --- | :-------: | :--: | :-------: | :--: | :--: | --- |
| 데이터 |     | @7103 ~ ? |  3   | @8104 ~ ? |  4   |      |     |

</br>

|  주소  | ... |          7103           |           7104            | 7105 | ... |
| :----: | --- | :---------------------: | :-----------------------: | ---- | --- |
| 데이터 |     | 이름: x </br> 값: @5003 | 이름: arr </br> 값: @5004 |      |     |

</br>

|  주소  | ... |          8104           |          8105           | 8106 | 8107 | 8108 | ... |
| :----: | --- | :---------------------: | :---------------------: | :--: | :--: | ---- | --- |
| 데이터 |     | 이름: 0 </br> 값: @5003 | 이름: 1 </br> 값: @5005 |      |      |      |     |

</br>
</br>
</br>

```js
var obj = {
  a: 3,
  arr: [3, 4],
};

obj.arr = "str"; // arr 이라는 프로퍼티에 문자열 값을 재할당
```

</br>

    'str' 을 새로운 데이터 공간에 저장 (5006)
    > obj.arr 을 찾음
    > 1002
    > 5002
    > arr 프로퍼티를 찾음
    > 7104 을 찾게 되고 7104 의 값을 5004 대신 5006로 재할당

</br>

|  주소  | ... |           1002            | 1003 | 1004 | ... |
| :----: | --- | :-----------------------: | ---- | ---- | --- |
| 데이터 |     | 이름: obj </br> 값: @5002 |      |      |     |

</br>

|  주소  | ... |   5002    | 5003 |   5004    | 5005 | 5006  | ... |
| :----: | --- | :-------: | :--: | :-------: | :--: | :---: | --- |
| 데이터 |     | @7103 ~ ? |  3   | @8104 ~ ? |  4   | 'str' |     |

</br>

|  주소  | ... |          7103           |           7104            | 7105 | ... |
| :----: | --- | :---------------------: | :-----------------------: | ---- | --- |
| 데이터 |     | 이름: x </br> 값: @5003 | 이름: arr </br> 값: @5006 |      |     |

</br>

|  주소  | ... |          8104           |          8105           | 8106 | 8107 | 8108 | ... |
| :----: | --- | :---------------------: | :---------------------: | :--: | :--: | ---- | --- |
| 데이터 |     | 이름: 0 </br> 값: @5003 | 이름: 1 </br> 값: @5005 |      |      |      |     |

</br>
</br>

    기본형에 비해 참조형이 메모리 할당 과정에 1단계를 더 거치기 때문에 기본형은 값이 바로 바뀌는 반면,  
    참조형은 똑같은 객체를 바라보고 있기에 값이 변하지 않게 된다.

</br>
</br>
</br>

### +) 남은 5004의 데이터들은 어떻게 될 것인가?

</br>

    5004를 참조하는 대상이 0개가 되어버림, 참조카운트가 0이라고 표현
    > 해당 메모리는 가비지컬렉터 (Garbage Collecting)의 수집 대상이 됨, 언젠가 사라지게 됨
    > 8104 ~ 데이터들도 연쇄적으로 참조카운트가 0이 되어버리고 역시나 가비지컬렉터의 수집 대상이 됨

</br>
</br>
</br>

### +) 값을 저장하는 방식에 따른 각각의 특징?

</br>

    <값을 직접 저장>
    - 데이터 할당시에는 빠름
    - 비교에 비용이 많이 듦
    - 메모리 낭비가 심함

    <값의 주소를 저장>
    - 데이터 할당시에는 느림
    - 비교에 비용이 들지 않음
    - 메모리 낭비 최소화
    - 비교에 비용이 들지 않음 (같은 값이 메모리 상에서 오직 하나만 존재=불변값)

</br>
</br>
